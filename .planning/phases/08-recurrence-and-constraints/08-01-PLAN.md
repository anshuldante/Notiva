---
phase: 08-recurrence-and-constraints
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/features/RECURRENCE.md
  - docs/README.md
autonomous: true

must_haves:
  truths:
    - "Developer can explain all 7 recurrence types and their millisecond values"
    - "Developer understands how getNextOccurrenceAfter() calculates next alarm time"
    - "Developer knows why WorkManager was chosen over AlarmManager alone"
    - "Developer understands Doze mode, battery optimization, and how setExactAndAllowWhileIdle handles them"
    - "Developer can debug recurrence issues using documented troubleshooting steps"
  artifacts:
    - path: "docs/features/RECURRENCE.md"
      provides: "Recurrence logic and Android constraints documentation"
      min_lines: 300
      contains: "RecurrenceType"
    - path: "docs/README.md"
      provides: "Updated navigation with RECURRENCE.md status"
      contains: "RECURRENCE.md"
  key_links:
    - from: "docs/features/RECURRENCE.md"
      to: "docs/features/NOTIFICATIONS.md"
      via: "Related Documentation section"
      pattern: "NOTIFICATIONS.md"
    - from: "docs/features/RECURRENCE.md"
      to: "docs/DATABASE.md"
      via: "RecurrenceType reference"
      pattern: "DATABASE.md"
---

<objective>
Document recurrence logic and Android platform constraints for Notiva reminder app.

Purpose: Enable developers to understand how recurring reminders work, why WorkManager was chosen, and how to handle Android-specific constraints like Doze mode and battery optimization.

Output: docs/features/RECURRENCE.md (300+ lines) with recurrence type reference, scheduling architecture, constraint handling, and updated docs/README.md navigation.
</objective>

<execution_context>
@/Users/ansagagr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ansagagr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Source files to document
@app/src/main/java/com/ava/notiva/model/RecurrenceType.java
@app/src/main/java/com/ava/notiva/model/ReminderModel.java
@app/src/main/java/com/ava/notiva/service/ReminderTriggerWorker.java
@app/src/main/java/com/ava/notiva/service/BootReceiver.java
@app/src/main/java/com/ava/notiva/util/ReminderWorkerUtils.java

# Related existing docs
@docs/features/NOTIFICATIONS.md
@docs/DATABASE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RECURRENCE.md with recurrence logic and Android constraints documentation</name>
  <files>docs/features/RECURRENCE.md, docs/README.md</files>
  <action>
Create docs/features/RECURRENCE.md (300+ lines) with the following sections:

1. **Overview** - Brief intro to recurrence system, link to related docs (NOTIFICATIONS.md, DATABASE.md)

2. **RecurrenceType Reference** - Table of all 7 types with:
   - Enum value (YEAR, MONTH, DAY, HOUR, MINUTE, FOREVER, NEVER)
   - Display text ("Year(s)", "Months(s)", etc.)
   - Milliseconds value (from getMillis() method)
   - Use case description
   - Note: MONTH uses 31-day approximation, YEAR uses 366 days for leap year handling

3. **Next Occurrence Calculation** - Document getNextOccurrenceAfter(Calendar now) algorithm:
   - Non-recurring case (NEVER or delay <= 0): Returns startDateTime if future, else null
   - Recurring case: interval = recurrenceType.getMillis() * recurrenceDelay
   - If startMillis > nowMillis: next = start
   - Else: Calculate intervalsPassed, compute next occurrence
   - FOREVER: Never checks end date
   - Others: Returns null if next > endDateTime
   - Include code snippet showing the actual algorithm

4. **Scheduling Architecture** - Mermaid diagram showing:
   - WorkManager -> ReminderTriggerWorker -> AlarmManager flow
   - OneTimeWorkRequest vs PeriodicWorkRequest usage
   - Why this hybrid approach works

5. **Why WorkManager + AlarmManager** - Decision rationale:
   - WorkManager alone: Cannot guarantee exact timing (subject to batching)
   - AlarmManager alone: Cleared on reboot, no retry/constraint handling
   - Hybrid approach: WorkManager schedules workers, AlarmManager fires exact alarms
   - Benefits: Exact timing, reboot persistence, battery-aware scheduling

6. **Android Constraints** section with subsections:

   a. **Doze Mode** - What it is, how setExactAndAllowWhileIdle() handles it

   b. **Battery Optimization** - App battery states, how to check/request exemption

   c. **Exact Alarm Permissions** - SCHEDULE_EXACT_ALARM vs USE_EXACT_ALARM, API levels, how to check canScheduleExactAlarms()

   d. **Boot Handling** - Why alarms are lost on reboot, how BootReceiver + PeriodicWorkRequest reschedules them

   e. **Foreground Service Requirements** - API 34+ mediaPlayback type requirement

7. **WorkManager Integration** section:
   - ReminderWorkerUtils.enqueueReminderWorker() usage
   - OneTimeWorkRequest for immediate scheduling after save/snooze
   - PeriodicWorkRequest (1-minute interval) after boot for ongoing scheduling
   - ExistingPeriodicWorkPolicy.KEEP for deduplication

8. **Recurrence Patterns** - Practical examples:
   - Daily reminder: recurrenceDelay=1, recurrenceType=DAY
   - Every 2 hours: recurrenceDelay=2, recurrenceType=HOUR
   - Weekly (7 days): recurrenceDelay=7, recurrenceType=DAY
   - Monthly: recurrenceDelay=1, recurrenceType=MONTH
   - Forever: recurrenceType=FOREVER, endDateTime ignored

9. **Debugging Guide** - Common issues:
   - Recurrence not firing (check active status, end date, permissions)
   - Wrong timing (check recurrenceDelay, millisecond calculations)
   - Alarms lost after reboot (check BootReceiver registration, RECEIVE_BOOT_COMPLETED)
   - Include adb commands for WorkManager inspection

10. **Next Steps** - Links to NOTIFICATIONS.md, REMINDERS.md, ARCHITECTURE.md

Also update docs/README.md:
- Change RECURRENCE.md status from "Planned" to "Available" in the navigation table
  </action>
  <verify>
1. File exists: `ls docs/features/RECURRENCE.md`
2. Line count >= 300: `wc -l docs/features/RECURRENCE.md`
3. Contains key terms: `grep -c "RecurrenceType\|getNextOccurrenceAfter\|WorkManager\|Doze\|setExactAndAllowWhileIdle" docs/features/RECURRENCE.md` (should be >= 20)
4. Has Mermaid diagram: `grep -c "mermaid" docs/features/RECURRENCE.md` (should be >= 1)
5. README updated: `grep "RECURRENCE.md" docs/README.md | grep -i "available"`
6. Links to related docs: `grep -c "NOTIFICATIONS.md\|DATABASE.md" docs/features/RECURRENCE.md` (should be >= 2)
  </verify>
  <done>
- RECURRENCE.md exists with 300+ lines
- All 7 recurrence types documented with millisecond values
- getNextOccurrenceAfter() algorithm explained with code
- WorkManager + AlarmManager architecture documented with rationale
- Android constraints section covers Doze, battery, permissions, reboot
- Debugging guide with adb commands included
- README.md shows RECURRENCE.md as "Available"
  </done>
</task>

</tasks>

<verification>
After task completion, verify:

1. **Content Accuracy:**
   - Millisecond values match RecurrenceType.java: MINUTE=60000, HOUR=3600000, DAY=86400000, MONTH=2678400000, YEAR=31622400000
   - Algorithm matches ReminderModel.getNextOccurrenceAfter() implementation
   - Permission names match AndroidManifest.xml

2. **Documentation Quality:**
   - Mermaid diagram renders correctly (check on GitHub)
   - Code snippets are syntactically correct Java
   - All cross-references to other docs are valid paths

3. **Navigation:**
   - RECURRENCE.md links back to README.md
   - README.md links to RECURRENCE.md
   - Related docs section includes NOTIFICATIONS.md and DATABASE.md
</verification>

<success_criteria>
Phase 8 is complete when:
- [ ] docs/features/RECURRENCE.md exists with 300+ lines
- [ ] All 7 recurrence types documented with enum values, display text, and milliseconds
- [ ] getNextOccurrenceAfter() algorithm fully explained
- [ ] WorkManager + AlarmManager architecture documented with "why" rationale
- [ ] Android constraints section covers: Doze mode, battery optimization, exact alarm permissions, boot handling
- [ ] Debugging guide included with adb commands
- [ ] docs/README.md updated to show RECURRENCE.md as "Available"
- [ ] All verification checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-recurrence-and-constraints/08-01-SUMMARY.md`
</output>
